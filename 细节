简历省略细节

心跳： 	因为要支持数万个客户端，因此不能用常规的“长连接”发送心跳包
	因此用建立和断开链接来模拟心跳。
	虽然 建立连接和断开链接都是需要消耗资源的，而且会有很多TIMEWAIT
	这样是为了维护业务完整性。
	而且还可以在配置文件中随时调整心跳的时间间隔， 可以调整并发度。
	
	 一个Master 与 一万个client

	非阻塞，select定时

	多线程可以抽象功能，我们希望一个线程可以做单独的功能。
	
	Ins: 一个线程负责一个链表，但是这样有问题：做不到绝对的负载均衡。因为可能有一个链表的用户全部掉线，这样负载就不均衡了。也就是说，只有加入新用户的时候能尽量确保负载均衡，但是不能保证一直（绝对）是负载均衡的。
	解决办法：线程池：多个线程 用 争夺资源的方式来处理用户。 从头上取出，处理完再插回尾部。
		这样要维护队列的长度，队列空了或满了。
		这样就实现了线程之间的负载均衡。
		这样也意味着对队列要互斥访问，要加锁，要用到条件变量。
		
		各有利弊：多个链表的插入和删除比较少，而线程池虽然保证了负载均衡，但是要频繁的取出和插入。
		
		多个链表的版本： 叫 资源池
		一个链表的版本： 叫 线程池


客户端：
	这是一个自己的实验项目。
	用了多进程，为什么不用多线程：因为想练习一下多进程之间的通信。
	获取信息：六个脚本
		最优的选择应该是用C语言来调用底层的接口，用脚本的话可能效率不太好。
		那你为什么用脚本：当时正在学shell
		CPU温度，转速。
		系统有个文件，里面保存了信息
		恶意进程：监测两次，两次均超过百分之五十的就标记为恶意进程。
			优化：白名单，黑名单。
		内存监测：free命令
		用户监测：passwd文件。大于1000就是普通用户，除去特殊的。
			当前在线：w命令  
		综合监测：

	怎么调用的脚本：popen(): 返回FILE指针。 先放在内存中，等到足够大的时候在写入硬盘，减少读写操作。
		写入硬盘时，内核也做了缓存（内核的回写机制！！！！），我这么缓存是和内核学的。

		为什么先存入硬盘再发送：要让Masster掌握收发的主导者，减少服务端的压力，而且服务端维护了链表的信息，因为客户端有上万。
		发送过程：同步机制！代替EPOLL。
			模拟TCP的三次握手。 不会发生阻塞。一个线程对一个一个连接


	同步： 
		同步IO， 协议三要素：语义、语法、语用， 加锁，线程同步，线程封闭
		协程：流程控制，就是一个子程序，用来控制程序的流程。
		直接IO：就是把IO请求提交给底层IO社诶处理，不经过内核缓存处理。
		同步IO：等待内核返回成功，但是此时内核可能并没有真正把内容写到内存中。
		异步IO：不等待内核返回，告诉 内核之后直接继续
		注意：同步和异步都是等待内核返回，并不能保证已经写到了硬盘上。停电就完犊子
	
	发文件：发完清空。要加锁，解释一下死锁：  如何避免死锁：避免死锁拥抱 abba baab， 如何避免：同顺序加锁。
	








	
